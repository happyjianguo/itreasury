/* Generated by Together */

package com.iss.itreasury.codingrule.bizlogic;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.sql.Date;
import java.util.HashMap;
import com.iss.itreasury.codingrule.dataentity.CodingRuleInfo;
import com.iss.itreasury.codingrule.dataentity.CodingRuleRelationInfo;
import com.iss.itreasury.codingrule.dataentity.CodingSectInfo;
import com.iss.itreasury.codingrule.dao.Sys_CodingRuleDao;
import com.iss.itreasury.codingrule.dao.Sys_CodingRuleRelationDao;
import com.iss.itreasury.codingrule.dataentity.CodingRuleInfo;
import com.iss.itreasury.codingrule.util.CodingRuleFormat;
import com.iss.itreasury.codingrule.util.RuleEnv;
import com.iss.itreasury.util.DataFormat;
import com.iss.itreasury.util.Database;
import com.iss.itreasury.util.IException;

import java.util.Iterator;

import org.apache.commons.beanutils.DynaBean;
import org.apache.commons.beanutils.ResultSetDynaClass;

/* Author:YanLiu */

public class CreateCodeBiz 
{
	private Class[] paraTypeClass = null;
	private Object[] paraObjectValue = null;
	private Connection conn = null;
	private boolean isSelfConnection = true;
	
	public CreateCodeBiz()
	{
	}
	public CreateCodeBiz(Connection con)
	{
		conn = con;
		isSelfConnection = false;
	}
	
	/*
	 * 根据传入的参数获取所需编码
	 * 描述:1.根据参数获取编码规则  2.根据所得的编码规则分段获取编码段，然后则合成完整编码
	 * @param       HashMap      	参数集合（key值为codingrule_paralist.xml对应，value为调用着设置）
	 * @return      String        	获取的完整编码
	 */
    public String creatCode( HashMap paraMap) throws IException,Exception
    {
		
		String strCode = "";
		//Connection conn = null;
		long codingRuleID = -1;
		paraMap.put("selfHashMap", paraMap);//将自身也作为HashMap的一个元素
		
		try
		{
            /*if(conn == null || conn.isClosed())
			{
				conn = Database.getConnection();
				isSelfConnection = true;
			}*/
			if(paraMap.get("connection") == null)
			{
				conn = Database.getConnection();
				isSelfConnection = true;
			}			
			else
			{
				conn = (Connection)paraMap.get("connection");
			}
			//根据HashMap参数获取编码规则id
			Sys_CodingRuleRelationDao relationDao = new Sys_CodingRuleRelationDao(conn);
			CodingRuleRelationInfo relationInfo = new CodingRuleRelationInfo();
		//	if(paraMap.get("officeID")!=null)
		//	{
				relationInfo.setOfficeID(Long.parseLong((String)paraMap.get("officeID")));
		//	}
		//	if(paraMap.get("currencyID")!=null)
		//	{
				relationInfo.setCurrencyID(Long.parseLong((String)paraMap.get("currencyID")));
		//	}
		//	if(paraMap.get("moduleID")!=null)
		//	{
				relationInfo.setModuleID(Long.parseLong((String)paraMap.get("moduleID")));
		//	}
		//	if(paraMap.get("transTypeID")!=null)
		//	{
				relationInfo.setTransTypeID(Long.parseLong((String)paraMap.get("transTypeID")));
		//	}
			if(paraMap.get("actionID")!=null)
			{
				relationInfo.setActionID(Long.parseLong((String)paraMap.get("actionID")));
			}
			
			if(paraMap.get("subActionID")!=null)
			{
				relationInfo.setSubActionID(Long.parseLong((String)paraMap.get("subActionID")));
			}
			codingRuleID = relationDao.findCodingRuleByCondition(relationInfo).getCodingruleID();
			
			if(codingRuleID<0)
			{
				throw new IException("获取编码出错：找不到业务对应的编码规则");
			}	
			
			
			//根据编码规则id获取编码规则
			CodingRuleBiz ruleBiz = new CodingRuleBiz();
	        CodingRuleInfo info = new CodingRuleInfo();
	        info = ruleBiz.findByID(codingRuleID);
	        
	        //根据编码规则和传入参数分段获取编码段，然后组合成编码
			Iterator it = info.getCodingRuleDetail().iterator();
			int i=1;
	        while(it.hasNext())
	        {
				CodingRuleInfo detailInfo = (CodingRuleInfo)it.next();
				CodingSectInfo codingSectInfo = (CodingSectInfo)RuleEnv.getInstance().getCodingSects().get(String.valueOf(detailInfo.getCodingSectID()));
	             String temp = "";
	            switch((int)codingSectInfo.getValue_type())
	            {
	            	case 1://静态文本	
	            		temp = getCodeByText(detailInfo,paraMap);
	            		break;
	            	case 2://通过sql获取                    
	                    temp = getCodeBySql(detailInfo,paraMap,conn);
	            		break;
	                case 3://通过指定方法获取
	                    temp = getCodeByMethod(detailInfo,paraMap);
	            		break;
	            }
	            if(detailInfo.getDigit()>0)
	            {
	            	temp = CodingRuleFormat.formatStringLength(temp,Integer.parseInt(String.valueOf(detailInfo.getDigit())));
	            }	
	            System.out.println("======第"+i+"段编码为："+temp);
	            i++;
	            strCode = strCode + temp;	//组合编码段
	        }
		}
		catch(IException ie)
		{
			ie.printStackTrace();
			throw ie;
		}
		catch(Exception e)
		{
			e.printStackTrace();
			throw new IException("获取编码出错!");
		}
		finally
		{
			if(isSelfConnection && conn!=null)
			{
				conn.close();
				conn = null;
			}	
		}
		return strCode;
    }
    
	/*
	 * 根据编码规则的分段信息和参数获取该段编码（sql方式）
	 * 描述:1.根据编码规则的分段信息和参数获取该段编码  2.格式化该段编码返回
	 * @param       CodingRuleInfo		编码规则分段信息 
	 * 				HashMap      		参数集合（key值为codingrule_paralist.xml对应，value为调用着设置）
	 * 				Connection			上层方法传递的链接，防止反复获取链接以提高效率（connection维护放在上层方法中）
	 * 				
	 * @return      String        		获取该段编码
	 */
    private String getCodeBySql(CodingRuleInfo ruleSectInfo,HashMap paraMap,Connection conn) throws Exception
    {
    	String strReturn = "";
    	PreparedStatement ps =null;
    	ResultSet rs = null;
    	try
    	{
    		CodingSectInfo codingSectInfo = (CodingSectInfo)RuleEnv.getInstance().getCodingSects().get(String.valueOf(ruleSectInfo.getCodingSectID()));
    		
    		String strSQL = codingSectInfo.getSql_string();
    		ps = conn.prepareStatement(strSQL);

    		String[] paraValueList = codingSectInfo.getParaValue();
    		if(paraValueList!=null && paraValueList.length>0)
    		{
	    		for(int i=0;i<paraValueList.length;i++)
	    		{
	    			ps.setString(i+1, (String)paraMap.get(paraValueList[i]));
	    		}
    		}
    		rs = ps.executeQuery();
    		
    		Object oResult = null;
    		if(rs.next())
    		{	
	    		if(codingSectInfo.getValue_return().equalsIgnoreCase("Timestamp"))
	    		{
	    			oResult = rs.getTimestamp(1);
	    		}
	    		else if(codingSectInfo.getValue_return().equalsIgnoreCase("Date"))
	    		{
	    			oResult = rs.getDate(1);
	    		}
	    		else if(codingSectInfo.getValue_return().equalsIgnoreCase("Time"))
	    		{
	    			oResult = rs.getTime(1);
	    		}
	    		else
	    		{
	    			oResult = rs.getString(1);
	    		}
    		}

    		//格式化结果
    		if(codingSectInfo.getFormat_type()>0)
    		{
    			strReturn = formatResult(codingSectInfo.getFormat_type(),oResult,ruleSectInfo.getReturnFormat());
    		}	
    		else
    		{
    			strReturn = oResult.toString();
    		}		
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    		throw new IException("获取编码出错（通过sql出错）");
    	}
    	finally
    	{
    		if(ps!=null)
    		{
    			ps.close();
    			ps = null;
    		}	
    		if(rs != null)
    		{
    			rs.close();
    			rs = null;
    		}	
    	}
    	return strReturn;
    }

	/*
	 * 根据编码规则的分段信息和参数获取该段编码（静态文本方式）
	 * 描述:1.根据编码规则的分段信息和参数获取该段编码  2.格式化该段编码返回
	 * @param       CodingRuleInfo		编码规则分段信息 
	 * 				HashMap      		参数集合（key值为codingrule_paralist.xml对应，value为调用着设置）
	 * 				
	 * @return      String        		获取该段编码
	 */
    private String getCodeByText(CodingRuleInfo ruleSectInfo,HashMap paraMap)
    {
    	String strReturn = "";
    	
    	strReturn = ruleSectInfo.getReturnFormat();
    	
    	return strReturn;
    }

	/*
	 * 根据编码规则的分段信息和参数获取该段编码（根据外部方法方式）
	 * 描述:1.根据编码规则的分段信息和参数获取该段编码  2.格式化该段编码返回
	 * @param       CodingRuleInfo		编码规则分段信息 
	 * 				HashMap      		参数集合（key值为codingrule_paralist.xml对应，value为调用着设置）
	 * 				
	 * @return      String        		获取该段编码
	 */    
    private String getCodeByMethod(CodingRuleInfo ruleSectInfo,HashMap paraMap) throws Exception
    {
    	String strReturn = "";
    	Class clazz = null;
    	Method method = null;
    	Class[] paraTypes = null;
    	Object oResult = null;
    	
    	try
    	{    		
    		CodingSectInfo codingSectInfo = (CodingSectInfo)RuleEnv.getInstance().getCodingSects().get(String.valueOf(ruleSectInfo.getCodingSectID()));
    		//获取类
    		clazz = Class.forName(codingSectInfo.getMethod_class());    		
    		//获取方法的参数类型列表
    		if(codingSectInfo.getParaType() !=null && codingSectInfo.getParaType().length>0)
    		{
    			preForMethod(codingSectInfo.getParaType(),codingSectInfo.getParaValue(),paraMap);
    		}
    		//获取方法
    		if(clazz!=null)
    		{
    			method = clazz.getMethod(codingSectInfo.getMethod_name(), paraTypeClass);
    		}
    		//调用方法，获取结果
    		oResult = method.invoke(clazz.newInstance(), paraObjectValue);

    		//格式化结果
    		if(codingSectInfo.getFormat_type()>0)
    		{
    			strReturn = formatResult(codingSectInfo.getFormat_type(),oResult,ruleSectInfo.getReturnFormat());
    		}	
    		else
    		{
    			strReturn = oResult.toString();
    		}	
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    		throw new IException("获取编码出错（通过方法出错）");
    	}
    	return strReturn;
    }

	/*
	 * 格式化各段编码
	 * 描述:根据编码规则的分段信息中的格式化类型格式化编码段
	 * @param       long formatType			格式化类型 
	 * 				Object formatValue		格式化数据
	 * 				String formatpara		格式化参数		
	 * 
	 * @return      String        			格式化后的的编码
	 */
    private String formatResult(long formatType,Object formatValue, String formatpara) throws Exception
    {
    	String strReturn = "";
    	try
    	{
    		if(formatValue instanceof Timestamp)
    		{    			
    			Timestamp ts = (Timestamp)formatValue;
    			strReturn = CodingRuleFormat.formatTimestamp(ts, formatpara);
    			   				
    		}
    		else if(formatValue instanceof Date)
    		{
    			Date date = (Date)formatValue;
    			strReturn = CodingRuleFormat.formatDate(date, formatpara);
    		}	
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    		throw new IException("格式化编码出错");
    	}
    	return strReturn;
    }
    
	/*
	 * 为方法调用做准备
	 */
    private Class[] preForMethod(String[] paraTypeList,String[] paraValueList, HashMap paraMap) throws Exception
    {
    	paraTypeClass = new Class[paraTypeList.length];
    	paraObjectValue = new Object[paraTypeList.length];
    	int i = 0;
        try
        {        	
        	if(paraTypeList!=null)
        	{        	
        		for (; i < paraTypeList.length; i++)
        		{
        			if(paraTypeList[i].equalsIgnoreCase("boolean"))
        			{	
        				paraTypeClass[i]=java.lang.Boolean.TYPE;
        				paraObjectValue[i] = java.lang.Boolean.valueOf((String)paraMap.get(paraValueList[i]));
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("char"))
        			{	
        				paraTypeClass[i]=java.lang.Character.TYPE;
        				paraObjectValue[i] = new java.lang.Character( ((String)paraMap.get(paraValueList[i])).toCharArray()[0]);
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("byte"))
        			{	
        				paraTypeClass[i]=java.lang.Byte.TYPE;
        				paraObjectValue[i] = java.lang.Byte.valueOf((String)paraMap.get(paraValueList[i]));
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("short"))
        			{	
        				paraTypeClass[i]=java.lang.Short.TYPE;
        				paraObjectValue[i] = java.lang.Short.valueOf((String)paraMap.get(paraValueList[i]));
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("int"))
        			{	
        				paraTypeClass[i]=java.lang.Integer.TYPE;
        				paraObjectValue[i] = java.lang.Integer.valueOf((String)paraMap.get(paraValueList[i]));
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("long"))
        			{	
        				paraTypeClass[i]=java.lang.Long.TYPE;
        				paraObjectValue[i] = java.lang.Long.valueOf((String)paraMap.get(paraValueList[i]));
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("float"))
        			{	
        				paraTypeClass[i]=java.lang.Float.TYPE;
        				paraObjectValue[i] = java.lang.Float.valueOf((String)paraMap.get(paraValueList[i]));
        			}	
        			else if(paraTypeList[i].equalsIgnoreCase("double"))
        			{	
        				paraTypeClass[i]=java.lang.Double.TYPE;
        				paraObjectValue[i] = java.lang.Double.valueOf((String)paraMap.get(paraValueList[i]));
        			}		
        			else
        			{	
        				paraTypeClass[i] = Class.forName(paraTypeList[i]);
        				paraObjectValue[i] = paraMap.get(paraValueList[i]);
        			}	
        		}
        	}
        }
        catch(ClassNotFoundException e)
        {
            throw new IException("类"+paraTypeList[i]+"没找到",e);
        }
        catch(Exception e)
        {
        	e.printStackTrace();
        	throw e;
        }
    	return paraTypeClass;
    }
    
    static public void main(String[] arg)
    {
    	try
    	{
    		HashMap hm = new HashMap();
    		hm.put("officeID", "1");
    		hm.put("currencyID", "1");
    		hm.put("moduleID", "1");
    		hm.put("transTypeID", "1");
    		hm.put("actionID", "-1");

    		
    		CreateCodeBiz biz = new CreateCodeBiz();
    		String strR = biz.creatCode( hm);
    		
    		System.out.println("++++value = "+strR);
    		
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    	}
    }

}
